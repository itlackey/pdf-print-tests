#!/usr/bin/env bun
/**
 * Convert PDF to PDF/X-1a:2001 using Ghostscript
 * Compliant with DriveThruRPG print-on-demand requirements
 */

import { $ } from "bun";
import { existsSync, mkdirSync, writeFileSync, unlinkSync } from "node:fs";
import { join, dirname, basename } from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT = join(__dirname, "..");

// DriveThruRPG compliant settings
const DTRPG_SETTINGS = {
  pdfStandard: "PDF/X-1a:2001",
  compatibilityLevel: "1.4",
  colorSpace: "CMYK",
  processColorModel: "DeviceCMYK",
  // CGATS21_CRPC1 is the recommended ICC profile for DriveThruRPG print-on-demand
  // This profile enforces a 240% TAC (Total Area Coverage) limit, preventing
  // excessive ink buildup that causes title pages to exceed 285-400% TAC.
  // It replaces rich black builds with controlled CMYK values for print compliance.
  iccProfile: join(__dirname, "..", "assets", "CGATS21_CRPC1.icc"),
  maxInkCoverage: 240, // TAC limit enforced by ICC profile
  dpi: 300,
  embedFonts: true,
  subsetFonts: true,
};

interface ConvertOptions {
  input: string;
  output: string;
  title?: string;
  iccProfile?: string;
}

/**
 * Generate PDF/X definition PostScript file
 * Note: This function is currently unused but maintained for reference
 */
function generatePdfxDef(options: {
  title: string;
  outputCondition: string;
  outputFile: string;
  iccProfile?: string;
}): string {
  const { title, outputCondition, outputFile, iccProfile = DTRPG_SETTINGS.iccProfile } = options;
  const isoDate = new Date().toISOString().split("T")[0].replace(/-/g, "");

  return `%!PS
% PDF/X-1a definition file for Ghostscript
% Generated by PDFX Test Harness

% Required for PDF/X-1a compliance
/ICCProfile (${iccProfile}) def

% PDF/X OutputIntent
[ /Title (${title})
  /OutputCondition (${outputCondition})
  /OutputConditionIdentifier (CGATS TR 001)
  /RegistryName (http://www.color.org)
  /Info (DriveThruRPG Print Ready)
  /Type /OutputIntent
  /S /GTS_PDFX
  /DestOutputProfile ICCProfile
] //.pdfxwriteobjdef

% Document Info
[ /Title (${title})
  /Creator (PDFX Test Harness)
  /Producer (Ghostscript)
  /CreationDate (D:${isoDate}120000+00'00')
  /ModDate (D:${isoDate}120000+00'00')
  /Trapped /False
  /GTS_PDFXVersion (PDF/X-1a:2001)
] //.pdfxwriteinfodef

% Set trapped value
true //.setpdfxtrapped
`;
}

/**
 * Generate a simpler PDFX definition that's more compatible
 * Note: This function is currently unused but maintained for reference
 */
function generateSimplePdfxDef(title: string, iccProfile: string = DTRPG_SETTINGS.iccProfile): string {
  const isoDate = new Date().toISOString().split("T")[0].replace(/-/g, "");

  return `%!PS-Adobe-3.0
% Minimal PDF/X-1a definition

/ICCProfile (${iccProfile}) def

mark
  /Author (PDFX Test Harness)
  /Title (${title})
  /Creator (PDFX Test Harness)
  /CreationDate (D:${isoDate}000000)
  /ModDate (D:${isoDate}000000)
  /Subject (Print-ready PDF/X-1a document)
  /Keywords (PDFX, print, CMYK, DriveThruRPG)
  /GTS_PDFXVersion (PDF/X-1a:2001)
  /Trapped /False
/DOCINFO pdfmark

% Output Intent
[
  /Type /OutputIntent
  /S /GTS_PDFX
  /OutputConditionIdentifier (Custom)
  /OutputCondition (CMYK printing)
  /Info (DriveThruRPG compliant output)
  /DestOutputProfile ICCProfile
] //.pdfxwriteobjdef
`;
}

export async function convertToPdfx(options: ConvertOptions): Promise<{
  success: boolean;
  outputPath: string;
  duration: number;
  gsVersion?: string;
  error?: string;
}> {
  const startTime = performance.now();
  const { input, output, title = "TTRPG Document", iccProfile } = options;

  // Ensure output directory exists
  const outputDir = dirname(output);
  if (!existsSync(outputDir)) {
    mkdirSync(outputDir, { recursive: true });
  }

  // Check input exists
  if (!existsSync(input)) {
    return {
      success: false,
      outputPath: output,
      duration: performance.now() - startTime,
      error: `Input file not found: ${input}`,
    };
  }

  console.log(`\nüîÑ Converting to PDF/X-1a with Ghostscript...`);
  console.log(`   Input:  ${input}`);
  console.log(`   Output: ${output}`);

  // Get Ghostscript version
  let gsVersion = "unknown";
  try {
    const versionResult = await $`gs --version`.quiet();
    gsVersion = versionResult.stdout.toString().trim();
    console.log(`   GS Version: ${gsVersion}`);
  } catch {
    console.log(`   GS Version: unknown`);
  }

  // Determine ICC profile to use
  // Priority: custom override > CGATS21_CRPC1 (DriveThruRPG recommended) > system fallbacks
  let profilePath = iccProfile || DTRPG_SETTINGS.iccProfile;

  // Check for ICC profile existence, prioritizing CGATS21_CRPC1
  const profileLocations = [
    join(ROOT, "assets", "CGATS21_CRPC1.icc"), // DriveThruRPG recommended - TAC limiting
    "/usr/share/color/icc/ghostscript/default_cmyk.icc",
    "/usr/share/ghostscript/iccprofiles/default_cmyk.icc",
    "/usr/share/color/icc/OpenICC/sRGB.icc",
  ];

  for (const loc of profileLocations) {
    if (existsSync(loc)) {
      profilePath = loc;
      break;
    }
  }

  console.log(`   ICC Profile: ${profilePath}`);

  try {
    // Build Ghostscript command for PDF/X conversion
    //
    // IMPORTANT LIMITATION: Simply embedding the CGATS21_CRPC1.icc profile does NOT
    // automatically reduce TAC. ICC profiles define color spaces but do not actively
    // transform existing colors in a PDF.
    //
    // TAC reduction requires one of the following approaches:
    // 1. Design-time: Create content with proper CMYK values (‚â§240% TAC)
    // 2. Pre-conversion: Use Photoshop/GIMP to apply GCR to images
    // 3. Post-processing: Use specialized TAC reduction tools (e.g., pdfToolbox)
    // 4. Custom GS script: Write PostScript to manipulate setcmykcolor operations
    //
    // This script embeds the CGATS21_CRPC1 profile correctly for DriveThruRPG
    // compliance, but existing high-TAC colors in the source PDF will remain.
    //
    // FONT EMBEDDING FIX: The -dPDFX=true flag causes Ghostscript to drop all fonts
    // during conversion. Removing this flag and relying on proper CMYK color space
    // conversion with ICC profile embedding achieves PDF/X-1a compliance while
    // preserving all embedded fonts (including Type 3 fonts from PagedJS).
    const gsArgs = [
      "gs",
      "-dBATCH",
      "-dNOPAUSE",
      "-dNOOUTERSAVE",
      "-dQUIET",
      "-sDEVICE=pdfwrite",
      `-dCompatibilityLevel=${DTRPG_SETTINGS.compatibilityLevel}`,
      // Color conversion to CMYK with embedded CGATS21_CRPC1 profile
      "-sColorConversionStrategy=CMYK",
      "-sProcessColorModel=DeviceCMYK",
      `-sOutputICCProfile=${profilePath}`, // Embed CGATS21_CRPC1 in output PDF
      `-sDefaultCMYKProfile=${profilePath}`, // Use CGATS21 as default CMYK space
      "-dOverrideICC=false", // Respect embedded profiles
      "-dDeviceGrayToK=true", // Convert DeviceGray to K-only (reduces TAC on grays)
      "-dBlackPtComp=2", // Black point compensation
      "-dUseCIEColor=true", // Use CIE color space for more accurate conversions
      // Image settings
      `-dColorImageResolution=${DTRPG_SETTINGS.dpi}`,
      `-dGrayImageResolution=${DTRPG_SETTINGS.dpi}`,
      `-dMonoImageResolution=${DTRPG_SETTINGS.dpi}`,
      // Font embedding (CRITICAL: all fonts must be embedded for print compliance)
      "-dEmbedAllFonts=true",
      "-dSubsetFonts=true",
      // Compression settings
      "-dAutoFilterColorImages=false",
      "-dColorImageFilter=/DCTEncode",
      "-dAutoFilterGrayImages=false",
      "-dGrayImageFilter=/DCTEncode",
      // PDF/X specific settings
      "-dPDFSETTINGS=/prepress",
      // NOTE: -dPDFX=true is REMOVED because it causes font embedding to fail.
      // PDF/X-1a compliance is achieved through proper color space conversion,
      // ICC profile embedding, and prepress settings without needing the PDFX flag.
      // Output
      `-sOutputFile=${output}`,
      input,
    ];

    // Run Ghostscript
    const result = await $`${gsArgs}`.quiet();

    const duration = performance.now() - startTime;

    if (existsSync(output)) {
      const stats = await Bun.file(output).stat();
      console.log(`   ‚úÖ Success! Generated ${((stats?.size ?? 0) / 1024).toFixed(2)} KB`);
      console.log(`   ‚è±Ô∏è  Duration: ${(duration / 1000).toFixed(2)}s`);
      return {
        success: true,
        outputPath: output,
        duration,
        gsVersion,
      };
    } else {
      return {
        success: false,
        outputPath: output,
        duration,
        gsVersion,
        error: "Output file was not created",
      };
    }
  } catch (error) {
    const duration = performance.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error(`   ‚ùå Error: ${errorMessage}`);
    return {
      success: false,
      outputPath: output,
      duration,
      gsVersion,
      error: errorMessage,
    };
  }
}

/**
 * Alternative conversion using a two-pass approach
 * First converts to CMYK, then applies PDF/X settings
 */
export async function convertToPdfxTwoPass(options: ConvertOptions): Promise<{
  success: boolean;
  outputPath: string;
  duration: number;
  error?: string;
}> {
  const startTime = performance.now();
  const { input, output, title = "TTRPG Document" } = options;

  const tempDir = join(ROOT, "output", "temp");
  if (!existsSync(tempDir)) {
    mkdirSync(tempDir, { recursive: true });
  }

  const intermediatePdf = join(tempDir, `${basename(input, ".pdf")}_cmyk.pdf`);

  console.log(`\nüîÑ Converting to PDF/X-1a (two-pass method)...`);

  try {
    // Pass 1: Convert to CMYK
    console.log(`   Pass 1: Converting to CMYK...`);
    await $`gs -dBATCH -dNOPAUSE -dQUIET -sDEVICE=pdfwrite \
      -sColorConversionStrategy=CMYK \
      -sProcessColorModel=DeviceCMYK \
      -dCompatibilityLevel=1.4 \
      -dEmbedAllFonts=true \
      -dSubsetFonts=true \
      -sOutputFile=${intermediatePdf} \
      ${input}`.quiet();

    if (!existsSync(intermediatePdf)) {
      throw new Error("Pass 1 failed: Intermediate PDF not created");
    }

    // Pass 2: Apply PDF/X settings
    console.log(`   Pass 2: Applying PDF/X settings...`);
    await $`gs -dBATCH -dNOPAUSE -dQUIET -sDEVICE=pdfwrite \
      -dPDFSETTINGS=/prepress \
      -dCompatibilityLevel=1.4 \
      -dColorImageResolution=300 \
      -dGrayImageResolution=300 \
      -sOutputFile=${output} \
      ${intermediatePdf}`.quiet();

    // Cleanup intermediate file
    if (existsSync(intermediatePdf)) {
      unlinkSync(intermediatePdf);
    }

    const duration = performance.now() - startTime;

    if (existsSync(output)) {
      const stats = await Bun.file(output).stat();
      console.log(`   ‚úÖ Success! Generated ${((stats?.size ?? 0) / 1024).toFixed(2)} KB`);
      console.log(`   ‚è±Ô∏è  Duration: ${(duration / 1000).toFixed(2)}s`);
      return {
        success: true,
        outputPath: output,
        duration,
      };
    } else {
      return {
        success: false,
        outputPath: output,
        duration,
        error: "Output file was not created",
      };
    }
  } catch (error) {
    const duration = performance.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error(`   ‚ùå Error: ${errorMessage}`);
    return {
      success: false,
      outputPath: output,
      duration,
      error: errorMessage,
    };
  }
}

// Run if called directly
if (import.meta.main) {
  const args = process.argv.slice(2);
  const dirFlagIndex = args.findIndex((a) => a === "--dir" || a === "--output");
  const dir = dirFlagIndex >= 0 ? args[dirFlagIndex + 1] : undefined;
  const remainingArgs = dirFlagIndex >= 0
    ? args.filter((_, idx) => idx !== dirFlagIndex && idx !== dirFlagIndex + 1)
    : args;
  
  if (remainingArgs.length < 2) {
    // Default: convert both PagedJS and Vivliostyle outputs in a project output directory
    const outputDirCandidate =
      dir ??
      (process.env.OUTPUT_DIR && process.env.OUTPUT_DIR.trim().length > 0
        ? process.env.OUTPUT_DIR
        : join(ROOT, "output", "default-test"));

    // Back-compat: if OUTPUT_DIR/default-test doesn't exist but OUTPUT_DIR contains PDFs, use it.
    const projectOutputDir = existsSync(join(outputDirCandidate, "pagedjs-output.pdf")) ||
      existsSync(join(outputDirCandidate, "vivliostyle-output.pdf"))
      ? outputDirCandidate
      : existsSync(join(ROOT, "output"))
        ? join(ROOT, "output")
        : outputDirCandidate;

    const pdfs = [
      {
        input: join(projectOutputDir, "pagedjs-output.pdf"),
        output: join(projectOutputDir, "pagedjs-pdfx.pdf"),
        title: "PagedJS PDF/X Output",
      },
      {
        input: join(projectOutputDir, "vivliostyle-output.pdf"),
        output: join(projectOutputDir, "vivliostyle-pdfx.pdf"),
        title: "Vivliostyle PDF/X Output",
      },
    ];

    for (const pdf of pdfs) {
      if (existsSync(pdf.input)) {
        await convertToPdfx(pdf);
      } else {
        console.log(`‚ö†Ô∏è  Skipping ${basename(pdf.input)} (not found)`);
      }
    }
  } else {
    const [input, output] = remainingArgs;
    await convertToPdfx({ input, output });
  }

  console.log("\n‚úÖ PDF/X conversion complete!");
}
