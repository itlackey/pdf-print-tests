#!/usr/bin/env bun
/**
 * Convert PDF to PDF/X-1a:2001 using Ghostscript
 * Compliant with DriveThruRPG print-on-demand requirements
 */

import { $ } from "bun";
import { existsSync, mkdirSync, writeFileSync, unlinkSync } from "node:fs";
import { join, dirname, basename } from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT = join(__dirname, "..");

// DriveThruRPG compliant settings
const DTRPG_SETTINGS = {
  pdfStandard: "PDF/X-1a:2001",
  compatibilityLevel: "1.4",
  colorSpace: "CMYK",
  processColorModel: "DeviceCMYK",
  // CGATS21_CRPC1 is the recommended ICC profile for DriveThruRPG
  // Falls back to generic CMYK if not available
  iccProfile: "/usr/share/color/icc/ghostscript/default_cmyk.icc",
  maxInkCoverage: 240, // TAC limit
  dpi: 300,
  embedFonts: true,
  subsetFonts: true,
};

interface ConvertOptions {
  input: string;
  output: string;
  title?: string;
  iccProfile?: string;
}

/**
 * Generate PDF/X definition PostScript file
 */
function generatePdfxDef(options: {
  title: string;
  outputCondition: string;
  outputFile: string;
}): string {
  const { title, outputCondition, outputFile } = options;
  const isoDate = new Date().toISOString().split("T")[0].replace(/-/g, "");

  return `%!PS
% PDF/X-1a definition file for Ghostscript
% Generated by PDFX Test Harness

% Required for PDF/X-1a compliance
/ICCProfile (${DTRPG_SETTINGS.iccProfile}) def

% PDF/X OutputIntent
[ /Title (${title})
  /OutputCondition (${outputCondition})
  /OutputConditionIdentifier (CGATS TR 001)
  /RegistryName (http://www.color.org)
  /Info (DriveThruRPG Print Ready)
  /Type /OutputIntent
  /S /GTS_PDFX
  /DestOutputProfile ICCProfile
] //.pdfxwriteobjdef

% Document Info
[ /Title (${title})
  /Creator (PDFX Test Harness)
  /Producer (Ghostscript)
  /CreationDate (D:${isoDate}120000+00'00')
  /ModDate (D:${isoDate}120000+00'00')
  /Trapped /False
  /GTS_PDFXVersion (PDF/X-1a:2001)
] //.pdfxwriteinfodef

% Set trapped value
true //.setpdfxtrapped
`;
}

/**
 * Generate a simpler PDFX definition that's more compatible
 */
function generateSimplePdfxDef(title: string): string {
  const isoDate = new Date().toISOString().split("T")[0].replace(/-/g, "");
  
  return `%!PS-Adobe-3.0
% Minimal PDF/X-1a definition

/ICCProfile (${DTRPG_SETTINGS.iccProfile}) def

mark
  /Author (PDFX Test Harness)
  /Title (${title})
  /Creator (PDFX Test Harness)
  /CreationDate (D:${isoDate}000000)
  /ModDate (D:${isoDate}000000)
  /Subject (Print-ready PDF/X-1a document)
  /Keywords (PDFX, print, CMYK, DriveThruRPG)
  /GTS_PDFXVersion (PDF/X-1a:2001)
  /Trapped /False
/DOCINFO pdfmark

% Output Intent
[
  /Type /OutputIntent
  /S /GTS_PDFX
  /OutputConditionIdentifier (Custom)
  /OutputCondition (CMYK printing)
  /Info (DriveThruRPG compliant output)
  /DestOutputProfile ICCProfile
] //.pdfxwriteobjdef
`;
}

export async function convertToPdfx(options: ConvertOptions): Promise<{
  success: boolean;
  outputPath: string;
  duration: number;
  gsVersion?: string;
  error?: string;
}> {
  const startTime = performance.now();
  const { input, output, title = "TTRPG Document", iccProfile } = options;

  // Ensure output directory exists
  const outputDir = dirname(output);
  if (!existsSync(outputDir)) {
    mkdirSync(outputDir, { recursive: true });
  }

  // Check input exists
  if (!existsSync(input)) {
    return {
      success: false,
      outputPath: output,
      duration: performance.now() - startTime,
      error: `Input file not found: ${input}`,
    };
  }

  console.log(`\nüîÑ Converting to PDF/X-1a with Ghostscript...`);
  console.log(`   Input:  ${input}`);
  console.log(`   Output: ${output}`);

  // Get Ghostscript version
  let gsVersion = "unknown";
  try {
    const versionResult = await $`gs --version`.quiet();
    gsVersion = versionResult.stdout.toString().trim();
    console.log(`   GS Version: ${gsVersion}`);
  } catch {
    console.log(`   GS Version: unknown`);
  }

  // Determine ICC profile to use
  let profilePath = iccProfile || DTRPG_SETTINGS.iccProfile;
  
  // Check for common ICC profile locations
  const profileLocations = [
    "/usr/share/color/icc/ghostscript/default_cmyk.icc",
    "/usr/share/ghostscript/iccprofiles/default_cmyk.icc",
    "/usr/share/color/icc/OpenICC/sRGB.icc",
    join(ROOT, "assets", "CGATS21_CRPC1.icc"),
  ];

  for (const loc of profileLocations) {
    if (existsSync(loc)) {
      profilePath = loc;
      break;
    }
  }

  console.log(`   ICC Profile: ${profilePath}`);

  try {
    // Build Ghostscript command for PDF/X conversion
    // Using a simpler approach that works without PDFX definition file
    const gsArgs = [
      "gs",
      "-dBATCH",
      "-dNOPAUSE",
      "-dNOOUTERSAVE",
      "-dQUIET",
      "-sDEVICE=pdfwrite",
      `-dCompatibilityLevel=${DTRPG_SETTINGS.compatibilityLevel}`,
      // Color conversion to CMYK
      "-sColorConversionStrategy=CMYK",
      "-sProcessColorModel=DeviceCMYK",
      "-dOverrideICC=true",
      // Image settings
      `-dColorImageResolution=${DTRPG_SETTINGS.dpi}`,
      `-dGrayImageResolution=${DTRPG_SETTINGS.dpi}`,
      `-dMonoImageResolution=${DTRPG_SETTINGS.dpi}`,
      // Font embedding
      "-dEmbedAllFonts=true",
      "-dSubsetFonts=true",
      // Compression settings
      "-dAutoFilterColorImages=false",
      "-dColorImageFilter=/DCTEncode",
      "-dAutoFilterGrayImages=false",
      "-dGrayImageFilter=/DCTEncode",
      // PDF/X specific settings
      "-dPDFSETTINGS=/prepress",
      "-dPDFX=true",
      // Output
      `-sOutputFile=${output}`,
      input,
    ];

    // Run Ghostscript
    const result = await $`${gsArgs}`.quiet();

    const duration = performance.now() - startTime;

    if (existsSync(output)) {
      const stats = await Bun.file(output).stat();
      console.log(`   ‚úÖ Success! Generated ${((stats?.size ?? 0) / 1024).toFixed(2)} KB`);
      console.log(`   ‚è±Ô∏è  Duration: ${(duration / 1000).toFixed(2)}s`);
      return {
        success: true,
        outputPath: output,
        duration,
        gsVersion,
      };
    } else {
      return {
        success: false,
        outputPath: output,
        duration,
        gsVersion,
        error: "Output file was not created",
      };
    }
  } catch (error) {
    const duration = performance.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error(`   ‚ùå Error: ${errorMessage}`);
    return {
      success: false,
      outputPath: output,
      duration,
      gsVersion,
      error: errorMessage,
    };
  }
}

/**
 * Alternative conversion using a two-pass approach
 * First converts to CMYK, then applies PDF/X settings
 */
export async function convertToPdfxTwoPass(options: ConvertOptions): Promise<{
  success: boolean;
  outputPath: string;
  duration: number;
  error?: string;
}> {
  const startTime = performance.now();
  const { input, output, title = "TTRPG Document" } = options;

  const tempDir = join(ROOT, "output", "temp");
  if (!existsSync(tempDir)) {
    mkdirSync(tempDir, { recursive: true });
  }

  const intermediatePdf = join(tempDir, `${basename(input, ".pdf")}_cmyk.pdf`);

  console.log(`\nüîÑ Converting to PDF/X-1a (two-pass method)...`);

  try {
    // Pass 1: Convert to CMYK
    console.log(`   Pass 1: Converting to CMYK...`);
    await $`gs -dBATCH -dNOPAUSE -dQUIET -sDEVICE=pdfwrite \
      -sColorConversionStrategy=CMYK \
      -sProcessColorModel=DeviceCMYK \
      -dCompatibilityLevel=1.4 \
      -dEmbedAllFonts=true \
      -dSubsetFonts=true \
      -sOutputFile=${intermediatePdf} \
      ${input}`.quiet();

    if (!existsSync(intermediatePdf)) {
      throw new Error("Pass 1 failed: Intermediate PDF not created");
    }

    // Pass 2: Apply PDF/X settings
    console.log(`   Pass 2: Applying PDF/X settings...`);
    await $`gs -dBATCH -dNOPAUSE -dQUIET -sDEVICE=pdfwrite \
      -dPDFSETTINGS=/prepress \
      -dCompatibilityLevel=1.4 \
      -dColorImageResolution=300 \
      -dGrayImageResolution=300 \
      -sOutputFile=${output} \
      ${intermediatePdf}`.quiet();

    // Cleanup intermediate file
    if (existsSync(intermediatePdf)) {
      unlinkSync(intermediatePdf);
    }

    const duration = performance.now() - startTime;

    if (existsSync(output)) {
      const stats = await Bun.file(output).stat();
      console.log(`   ‚úÖ Success! Generated ${((stats?.size ?? 0) / 1024).toFixed(2)} KB`);
      console.log(`   ‚è±Ô∏è  Duration: ${(duration / 1000).toFixed(2)}s`);
      return {
        success: true,
        outputPath: output,
        duration,
      };
    } else {
      return {
        success: false,
        outputPath: output,
        duration,
        error: "Output file was not created",
      };
    }
  } catch (error) {
    const duration = performance.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error(`   ‚ùå Error: ${errorMessage}`);
    return {
      success: false,
      outputPath: output,
      duration,
      error: errorMessage,
    };
  }
}

// Run if called directly
if (import.meta.main) {
  const args = process.argv.slice(2);
  
  if (args.length < 2) {
    // Default: convert both PagedJS and Vivliostyle outputs
    const pdfs = [
      {
        input: join(ROOT, "output", "pagedjs-output.pdf"),
        output: join(ROOT, "output", "pagedjs-pdfx.pdf"),
        title: "PagedJS PDF/X Output",
      },
      {
        input: join(ROOT, "output", "vivliostyle-output.pdf"),
        output: join(ROOT, "output", "vivliostyle-pdfx.pdf"),
        title: "Vivliostyle PDF/X Output",
      },
    ];

    for (const pdf of pdfs) {
      if (existsSync(pdf.input)) {
        await convertToPdfx(pdf);
      } else {
        console.log(`‚ö†Ô∏è  Skipping ${basename(pdf.input)} (not found)`);
      }
    }
  } else {
    const [input, output] = args;
    await convertToPdfx({ input, output });
  }

  console.log("\n‚úÖ PDF/X conversion complete!");
}
